{
  "name": "Hawkecs-swift",
  "tagline": "A protocol oriented entity component system written in Swift",
  "body": "Inspired by: \r\n   \r\n   https://github.com/adamgit/Entity-System--RDBMS-Inspired--Objective-C\r\n   \r\n   http://www.swift-studies.com/blog/2015/7/21/making-gameplaykit-swift-ier\r\n\r\n## Protocols\r\n### HKType\r\n - Provides a type property that returns the DynamicType as a String\r\n\r\n### HKUpdatable\r\n  - Declares one function: updateWithDeltaTime(seconds: )\r\n\r\n### HKComponent\r\n  - Conforms to HKType and HKUpdatable\r\n  - Provides a default implementation of HKUpdatable\r\n  - Can be used to turn anything in your code into a component. e.g SKPhysicsBody, CGPoint\r\n  - Immutable structs are preferred for components\r\n\r\n### HKComponentSystem\r\n  - Conforms to HKType and HKUpdatable\r\n  - Declares one property, var engine: HKEngine!\r\n  - Use updateWithDeltaTime(seconds: ) to update components in your engine\r\n  - You can define your component system as a struct or a class\r\n\r\n\r\n## Structs\r\nStructs are favoured where possible\r\n### HKEntity\r\n  - A simple struct allowing your code to be more readable\r\n  - It has five properties: \r\n        identifier: HKEntityIdentifier\r\n        ID: Int\r\n        name: String\r\n        group: String\r\n        engine: HKEngine\r\n  - Provides convenience functions\r\n \r\n### HKEntityIdentifier\r\n  - Store identity data for the entities in your game\r\n  - It has three properties\r\n        id: Int\r\n        name: string\r\n        group: String\r\n\r\n### HKComponentDictionary\r\n  - The component dictionary is the heart of the engine\r\n  - It stores all of the components in your game\r\n  - Components are organised by type\r\n  - Each type is further organised by entity id\r\n\r\n### HKEntityCollection\r\n  - The entity collection stores HKEntityIdentifier structs\r\n \r\n### HKSystemCollection\r\n  - Stores the HKComponentSystems used in your game\r\n\r\n\r\n## Classes\r\n### HKEngine\r\n  - Conforms to HKUpdatable\r\n  - Manages creating and maintaining entities\r\n  - Holds HKComponentSystems and sequentially updates them when updateWithDeltaTime(seconds: ) is called\r\n\r\n\r\n  \r\n  \r\n## Usage\r\n  \r\n  Initialize\r\n  ```Swift\r\n  let engine = HKEngine()\r\n  ```\r\n  \r\n  Create a custom component\r\n  ```Swift\r\n  struct HealthComponent: HKComponent {\r\n    let max = 100\r\n    let current = 100\r\n  }\r\n  ```\r\n  \r\n  Use built in structs and class as components\r\n  ```Swift\r\n  extension CGPoint: HKComponent {}\r\n  public typealias PositionComponent = CGPoint\r\n  \r\n  extension CGVector: HKComponent {}\r\n  public typealias VelocityComponent = CGVector\r\n  ```\r\n  \r\n  Create a component system\r\n  ```Swift\r\n  struct MovementSystem: HKComponentSystem {\r\n  \r\n    // Pointer to engine\r\n    weak let engine: HKEngine!\r\n  \r\n    // AddToEngine\r\n    func didMoveToEngine(engine: HKEngine) {\r\n      self.engine = engine\r\n    }\r\n  \r\n    // Update\r\n    func updateWithDeltaTime(seconds: NSTimeInterval) {\r\n    \r\n      engine.filter(VelocityComponent.self) {\r\n        entity, velocity in\r\n        \r\n        guard let position: PositionComponent = engine.getComponent(forEntity: entity) else { return }\r\n        \r\n        let x = position.x + velocity.dx\r\n        let y = position.y + velocity.dy\r\n        \r\n        update(PositionComponent(x: x, y: y), forEntity: entity)\r\n      }\r\n  }\r\n    \r\n    func willMoveFrom(engine: HKEngine) {\r\n      self.engine = nil\r\n    }\r\n  }\r\n```\r\n\r\nCreate an entity\r\n```Swift\r\nlet entity = engine.createEntity(\"player\", group: \"userControlled\")\r\n```\r\n\r\nAdd components\r\n```Swift\r\nentity.addComponent(PositionComponent())\r\nentity.addComponent(VelocityComponent())\r\n```\r\n\r\nRetrieve a component\r\n```Swift\r\nif let position: PositionComponent = entity.getComponent() {\r\n  // Do something with position\r\n}\r\n```\r\n\r\nAdjust a component\r\n```Swift\r\nentity.adjustComponent(PositionComponent.self) {\r\n  $0.x = 0\r\n  $0.y = 0\r\n}\r\n```\r\n\r\nRemove a component\r\n```Swift\r\nentity.removeComponent(PositionComponent.self)\r\n```\r\n\r\nRemove an entity\r\n```Swift\r\nentity.destroy()\r\n```\r\n\r\nUpdate the engine\r\n```Swift\r\noverride func update(currentTime: CFTimeInterval) {\r\n  deltaTime = currentTime - timeSinceLastUpdate\r\n  deltaTime = deltaTime > maxUpdateInterval ? maxUpdateInterval : deltaTime\r\n  lastUpdateInterval = currentTime\r\n  \r\n  engine.updateWithDeltaTime(deltaTime)\r\n}\r\n```\r\n\r\nFilter the entities\r\n```Swift\r\nlet enemies = engine.getEntityGroup(\"enemies\")\r\nlet player = engine.getEntity(\"player\")\r\n```\r\n\r\nFilter the components\r\n```Swift\r\nengine.filter(PositionComponent.self) {\r\n  entity, position in\r\n}\r\n\r\nengine.filter(PositionComponent.self, entityGroup: \"enemies\") {\r\n  entity, position in\r\n}\r\n```\r\n\r\nFilter the systems\r\n```Swift\r\nengine.filter(MovementSystem.self) {\r\n  movementSystem in\r\n}\r\n```\r\n\r\nFeel free to use this ECS as an alternative to the GameplayKit ECS\r\n\r\nnote: GKAgent can be made into a component using the HKComponent protocol. \r\n      The updateWithDeltaTime(seconds: ) method \r\n      will need to be called within your GKAgentComponentSystem\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}